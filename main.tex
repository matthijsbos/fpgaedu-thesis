\documentclass[openright]{template/uva-bachelor-thesis}
\usepackage{graphicx}
\usepackage{url}
\usepackage{enumitem}
\usepackage{multicol}
\usepackage{csquotes}
\usepackage[margin=1cm,format=hang]{caption}
\usepackage{subcaption}	
\usepackage{pdflscape}
\usepackage{float}
\usepackage{tocbibind}


\usepackage{hyperref}
\usepackage{cleveref}

\usepackage[style=ieee,backend=bibtex]{biblatex}
\addbibresource{cite.bib}

% Title Page
\title{A model for \\experiment setups on\\ FPGA development boards}
\author{Matthijs Bos}
\supervisors{Anthony van Inge (UvA), Taco Walstra (UvA)}
\signedby{n.a.}


\begin{document} 

\maketitle

\begin{abstract}
TODO
\end{abstract}

\tableofcontents

\chapter{Introduction}
\label{chapterintroduction}
% nog niet helemaal logisch
The use of field-programmable gate arrays (FPGA) has increased a lot in the past years. FPGAs have been successfully applied in many industries as well as in academic research. Manufacturers have put a great effort in further developing the capabilities of FPGAs, resulting in an increase in performance and size, as well as a decrease in power consumption and unit cost. Due to their high cost, FPGAs used to be unsuitable for application in classroom teaching. The developments of the past years however, put FPGAs within the reach of academic education. Nowadays, a full-featured FPGA development board can be acquired for under \$150. 

Computer architecture and organization is considered an important subject in the computer science program taught at the University of Amsterdam (UvA). The subject is taught to freshmen as an eight week course in an early stage of their curriculum. The subject's body of knowledge ranges from a low level understanding of a computer's central processing unit's (CPU) inner workings, design and surrounding systems to a more abstract view of the CPU that considers its instruction set from a software point of view.

% SIM-PL welof niet noemen?
% Minder vanuit UvA, Meer vanuit Henessy and Patterson
% dieper ingaan op experimenten?
% meer focus op high-level, minder op digital design
The UvA's course contents are based on the widely adopted works of Hennessy and Patterson, supported by a number of lab experiments. These lab experiments allow students to reinforce their theoretical understanding of the course's subject matter by interacting with a number of virtual computer architectures in a simulator environment. In the process of modernizing the computer architecture and organization course, the instructors sense the need for a more hand-on experience in which students are capable of interacting with physical devices. This physical view of a computer architecture may aid in a student's understanding of the subject matter.

Hardware design is not part of the computer science curriculum.

Using FPGAs to experiment with (variations of) live computer architecture implementations to perform qualitative experiments instead of doing (partial) actual implementation. HDL programming is not a part of the curriculum.

FPGAs allow for a computer architecture design to be taken out of the virtual environment of a simulator and be implemented in a physical device. As such, they may provide a solution in achieving the goals of the UvA's computer architecture and organization course instructors. The technical capabilities of FPGAs combined with the decreased cost of FPGA development boards makes their adoption in the course a viable option. 

Utilizing FPGAs however, is a complex task that requires a specific set of skills, including digital design, hardware definition language (HDL) programming and familiarity with specialized development tools. Their complexity and the set of skills required raises problems in the application of FPGAs in an eight week introductory level computer architecture and organization course. Each of these skills may deserve a course on their own and are mostly beyond the scope of the UvA's undergraduate computer science curriculum. 

This thesis presents a generic solution that allows for students to utilize FPGAs in their lab experiments without the requirement of these more advanced skills. Experiments are performed using a Digilent Nexys 4 FPGA board, connected to a PC. An implementation is provided and validated through a number of experiments in which multiple variants of Hennessy and Patterson's MIPS computer architecture are running on an FPGA. The scope of this thesis is limited to a technical solution and does not evaluate the didactic effects of a hands-on approach in the teaching of these subjects.


\section{Problem Statement and Related Work}
\label{sectionproblemstatement}

% TODO er wordt bijna geen woord besteed aan simulators
% TODO RTL beter benadrukken
% TODO melden dat EE en CE niet op de UvA onderwezen worden

In their teaching of computer architecture and organization at the University of Amsterdam's (UvA) department of computer science, the course instructors see an opportunity for improvement through introduction of FPGA development boards as a tool for experimentation during practical exercises. The instructors sense the need for a hands-on approach in teaching their subjects, since computer science students lack experience with physical hardware. The course is taught early in the first year of undergraduate students over a period of two months, so students are not expected to have any academic experience in the field of computer science. 


\subsection{A Shift in Focus}
Although computer architecture and organization is part of the curricula of electrical engineering, computer engineering and computer science students, its place is different in each curriculum. 
For electrical engineering students, digital systems are the final station in terms of abstraction. For computer science students, it's the start of a journey. Computer engineering can be considered to be in the middle of this spectrum. The UvA's instructors aim to shift the course's focus to the abstract aspects of digital systems, such as instruction-level parallelism and caching strategies in computer architectures. The instructors find a higher-level level view of digital systems on a register-transfer level and an instruction level to be more in line with a computer science student's curriculum. Only a basic understanding of lower-level subjects such as digital design and electronic is pursued. In their decision, the instructors follow a trend that was observed in \cite[p. 205]{cs2013final}: a de-emphasis of digital design in computer science curricula. Deep coverage of digital design is considered to more appropriate in the curricula of electrical engineering and computer engineering. 

The UvA's computer architecture and organization course contents are based on the works of Hennessy and Patterson \cite{hennessy2013computer} which considers the design process of a microprocessor from a higher-level view. In their work there is a significant focus on the numerical analysis of decisions made in that process. The instructors' intended goal for their practical sessions is to allow students to analyse the implications of these higher-level design decisions through experimentation. As also noted in \cite{paharsingh2009novel}, students who have not experimented with abstract subjects such as pipelining and caching show lower test scores in these areas. 

By way of example, the instructors would like to be able to provide students with a series of implementations of MIPS architectures, corresponding to those described in \cite[Ch. 4]{hennessy2013computer}. Students could be asked to write a program that would demonstrate the effects of some optimization that is described in the textbook. The introduction of some form of hazard detection, for instance. Students could then be required to execute their programs on both computer architectures and describe their observations as well as the measured performance effects. 



\subsection{Physical component}

Moving away from the lower-level aspects of computer architecture and organization contradicts with the instructors' observation that computer science students lack in their experience with computer hardware. However, the UvA's instructors believe that the introduction of a physical component in their practical sessions could present a solution. Although the instructors aim to focus on the more abstract subjects, letting students experiment with these subjects through physical devices could implicitly develop a student's intuition for hardware-related concepts and support students in gaining a basic understanding of the lower-level aspects of computer architectures. Furthermore, the instructors believe that this approach to teaching will allow students to gain a better insight in more abstract concepts, since students are enabled to see these concepts  implemented in real, functioning hardware.

The instructors have identified FPGAs as a viable candidate to fulfill this need for a physical component in their teaching. FPGAs have been adopted in teaching for similar reasons. 
In \cite{cifredo2015computer, oztekin2011bzk} FPGAs have been included in the teaching as a solution to the need for a hands-on approach in the teaching of computer architecture and organization.
In \cite{el2011teaching} is observed that computer science lack experience with physical hardware.
FPGAs have been applied in the curricula of \cite{paharsingh2009novel, jansen2014every, el2011teaching, pereira2012basic, cifredo2015computer, kellett2012project, el2011teaching, pereira2012basic, lee2012pipelined, oztekin2011bzk, bulic2013fpga, el2011teaching, pereira2012basic, lee2012pipelined, oztekin2011bzk, nakano2008processor, al2007teaching} and have proven to be a valuable tool in teaching computer architecture and organization. 
In \cite{bulic2013fpga} students have reported an increased insight into the subjects taught. In particular, an increased insight in abstract subjects such as pipelining is observed, since students are provided with an accurate view of the computer architecture's internal state. Furthermore, the adoption of FPGAs had resulted in an increase in student motivation, especially when subject became more challenging. 
In \cite{oztekin2011bzk} students have reported an increased learning experience. 
In \cite{lee2012pipelined} the adoption of FPGAs has led to the observation that students gained an increased confidence with hardware and has provided them with an overall view of a computer system as well as its relation to software. Furthermore, visual verification of results on the FPGA development board has helped their students in gaining a better understanding of computer systems and an increased motivation.
In \cite{paharsingh2009novel} an increased student pass rate, student score and student evaluation were observed.  
In \cite{cifredo2015computer} students have reported an increased interest in the subject matter as well as an increased insight
In \cite{el2011teaching} students have showed better performance and understanding through the adoption of FPGA development boards, as opposed to simulation-based methods. 


\subsection{Implementation-based Methods}

Known methods for teaching computer architecture and organization using FPGAs, such as \cite{paharsingh2009novel, el2011teaching, nakano2008processor, al2007teaching, kellett2012project, jansen2014every, pereira2012basic, cifredo2015computer, lee2012pipelined} focus on implementation and validation. These methods describe how students are enabled in creating a working computer architecture through implementation. FPGAs are mainly used as a means for students to validate their work, after having designed and simulated their work using electronic design automation (EDA) tools. 

Due to the complexities involved in implementing a computer architecture, combined with a limited amount of time, students are constrained in the complexity of their implementations. Computer architecture is considered to be a challenging task, in which one has to address problems on different abstraction levels. As a result, these methods primarily feature implementation of simplified single-cycle machines which are limited in instruction sets and applied optimizations. Only in \cite{lee2012pipelined} a method is presented in which students focus on the implementation of a pipelined MIPS architecture. Although this method enables students in creating a working design over a period of two months, more advanced optimizations are omitted from the project due to a lack of time and no attention is paid to other subjects such as caching and I/O. Furthermore, none of these methods ask students to evaluate the decisions they have made during in the process of implementing their designs.  The UvA's course instructors believe that these methods suffice in the teaching of basic computer architecture concepts, but are insufficient in explaining more complex subjects to students.

% in \cite{lee2012pipelined} zeggen ze juist dat een benadering zonder implementatie studenten demotiveert

The time available to students for implementation is limited by the acquisition of the skills required in order to successfully implement a working computer architecture on a FPGA. Not only are students required to have an understanding of digital design and digital systems, but familiarity with additional subjects such as HDL modelling, FPGA development and experience with the involved EDA tools is also required. As a consequence, these methods are mostly targeted at more experienced students who have studied these prerequisite subjects earlier in their programmes. The methods presented in \cite{lee2012pipelined, kellett2012project} are targeted at students who are in later stages of undergraduate programs. The methods presented in \cite{nakano2008processor, jansen2014every, pereira2012basic} are known to be targeted at graduate students. 

Since the UvA's course is targeted at inexperienced first-year computer science students, the acquisition of these skills would take up a significant amount of time before they could create designs of meaningful definition. As shown in \cite[Fig. 1]{jansen2014every}, one could designate separate courses for each of these subjects individually. Only in \cite{cifredo2015computer} a method is presented in which first-year students are taught the subject of computer architecture and organization whilst simultaneously acquiring a basic understanding of HDL programming through implementation exercises. An important observation is that first-year students struggle in adopting the concurrent characteristics of HDL modelling, as opposed to the imperative style of programming they may already be familiar with. 

As previously stated, the UvA's computer science students are only required to be familiar with the concepts of digital systems and to have a basic understanding of digital design. The aforementioned additional skills, such as HDL modelling are not part of the students' curriculum. The students would be unnecessarily burdened by these requirements. One could conclude that the discussed implementation-based methods are thus better suited to the curricula of electrical engineering and computer engineering, since the prerequisite subjects are often taught as part of these curricula. 

% EDA Development en simulation tools zijn gericht op implementatie debugging en validation. niet op het verzamelen van experimentele resultaten. Docenten zijn vervolgens weer zelf verantwoordelijk voor de tools om deze resultaten te creeren.


\subsection{Ready-made Solutions}

Not all known methods that include FPGAs in their teaching require students to create their own implementations. The methods described in \cite{holland2003harnessing, bulic2013fpga, mipsfpga} consider FPGAs as a tool for containment of existing computer architectures. Through these methods, students are enabled to execute their programs on 'real hardware' and interact with the computer architecture's internal state through software on the user's PC. As opposed to ASIC-based methods that serve a similar goal, these methods have the advantage of providing students with a detailed view of the computer architecture's internal signals and state.

Unfortunately, these methods do not allow the UvA's instructors to provide students with a series of varying computer architecture implementations. Only limited variation is offered in the implementations of these computer architectures. In \cite{holland2003harnessing, bulic2013fpga}, a single-cycle version and a pipelined version of these computer architectures are offered. In \cite{mipsfpga} only a single computer architecture is provided, although extensive in terms of features. These methods' primary focus is to enable students to experiment with computer architectures on an instruction level and provide insight into the computer architecture's internal state. 
% These methods also feature a means for compilation and assembly of user.

In \cite{holland2003harnessing, bulic2013fpga} specialized logic is developed for containment of the computer architecture into the FPGA and for communication with the PC software. As also noted in \cite{bulic2013fpga}, it is designed for a specific FPGA development board and not very portable due to the use of board-specific features. This dependency makes it difficult for these methods to be adapted to other environments. In \cite{mipsfpga} a more modular approach is taken in which a simple wrapper is provided for embedding the computer architecture in a number of popular FPGA development boards. An EJTAG module is developed that serves as the primary means of interaction with the computer architecture. Through adoption of industry standards, existing hardware and software tools can be used for programming and debugging purposes. Board I/O pins expose this module's interface to the user. However, this approach prevents this method from being a self-contained solution. Separate programming and debugging hardware is required in order for students to be able to interact with the computer architecture and their executing programs via PC software. 

The PC software provided in \cite{holland2003harnessing, bulic2013fpga} is easily understood and little knowledge other than that of the computer architecture, its instruction set and programming is required in order for students to be able to use it in their practical sessions. However, this software is specifically developed for a single combination of development board and its contained logic (computer architecture and encapsulating logic). These dependencies limit the use of these PC software implementations to their respective methods. Any change in development board, the computer architecture or its encapsulating logic would require modification of the PC software. The dependencies identified between these methods' components do not only limit their use, but complicates their development process as well. 

Adapting these methods' implementations to fit the UvA's instructors' goals could be possible, but would require an investment that is not easily repaid. These methods lack a generic approach to the problem of embedding a computer architectures into FPGA development boards. Applying these methods' approaches to a large number of varying computer architectures would produce a solution that is not easily maintained, due to the dependencies that are created in the process of development. Furthermore, the final solution would require extensive modifications to be adapted to other environments, due to the limitations of a board-specific development process. Additionally, such an approach would distract instructors from their task of developing computer architectures for their education and would require them to focus on peripheral matters. 


\subsection{Wrap-up}
The UvA's computer architecture and organization course instructors require a solution that allows their students to experiment with a series of varying computer architecture implementations. FPGAs may provide a physical approach to this problem, but current methods incorporating FPGA development boards do not provide a satisfying solution. Implementation-based methods do not manage to address the more complex subjects and are not suited to curriculum of the UvA's computer science students, due to the skills required. Students must be able to use FPGAs solely as tool for containment of ready-made computer architectures, without being burdened with the complexities of these devices. Hiding these complexities allows for students to focus on the higher-level aspects of these computer architectures and performing meaningful experiments, while the physical approach aids students in gaining an intuition for computer hardware.

Some existing methods hide these complexities form their students, but only feature fixed computer architecture implementations. These systems are built from tightly-coupled components that do not allow for easy modification of the featured computer architecture. In order for the UvA's instructors to achieve their goal, a generic approach to embedding digital systems in FPGAs is required, allowing instructors to provide their students with a range of varying computer architecture implementations, while reusing standard components for containment within the FPGA and using generic PC software. The instructors' work should focus on implementing a computer architecture. Furthermore, their work should be easily adaptable to different FPGA development boards.

\section{Thesis Scope}
Although this thesis' problem statement discusses various didactic aspects of the teaching of computer architecture and organization, evaluation of the proposed solution's educational value is explicitly excluded from this thesis' scope. The goal of this thesis is to find a technical solution that satisfies the UvA's instructors' requirements as described in the problem statement. 


\section{Research Question}

In order for FPGAs to provide students with a hands-on experience during their lab experiments, a solution is required 
that removes the need for skills such as HDL programming and abstracts the complexities of working with FPGAs.

This thesis' research question is as follows: 

\begin{displayquote}
How can FPGAs be applied in computer architecture and organization lab experiments, while hiding their technical complexities and removing the need for HDL programming skills?
\end{displayquote}







\chapter{Background}

% TODO
% - terminologie compilation toolchain
% - infer block ram during compilation

\section{Field-programmable gate arrays}
Field-programmable gate arrays (FPGA) are a class of integrated circuits (IC) which' behaviour is reconfigurable, as opposed to application specific integrated circuits (ASIC). In their most common form, FPGAs consist of configurable logic blocks (CLB), combined with a configurable network that interconnects these. Many manufacturers combine CLBs with additional static functionality such as memories, I/O controllers and even embedded microprocessors. Which static features are included differs per FPGA model and manufacturer. Figure \ref{fig:fpgastructure} gives a structural overview of a FPGA as manufactured by Xilinx. It shows a number of CLBs, interconnected with I/O blocks (IOB) that connect IC package pins and block rams (BRAM) which serve as static blocks of memory. The digital clock manager (DCM) is responsible for the distribution of clock signals to every of the FPGA's blocks. 

A CLB's contained logic is described through an internal lookup table in which 

\begin{figure}
\centering
\includegraphics[width=.7\textwidth]{img/fpga-block-structure}
\caption{Structural FPGA overview \cite{xilinxFPGA}}
\label{fig:fpgastructure}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=.7\textwidth]{img/fpga-clb}
\caption{FPGA CLB example overview \cite{fpgaclbimg}}
\label{fig:my_label}
\end{figure}



\subsection{I/O capabilities}
A FPGA development board generally includes a number of I/O devices. Simple devices for input include buttons and switches, while simple output devices are generally LEDs or LED displays. Furthermore, a development board often includes a set of pin headers, which can be configured individually to be input or output ports. 

More complex I/O devices are included as well. Such as VGA output controllers, microphone, Ethernet, USB, .... These devices operate within strict timing constraints in order to work properly. This prevents the experiment setup from properly using the device, since it runs on a irregular, low frequency. 

Buffering (right term?) of some types of input, such as push buttons. When a user presses a push button while the experiment is halted, the signal should be artificially set to be high during the next cycle.

I/O devices can only be seen as combinational circuits. I/O devices that are based on sequential logic, such as a LED display controller, an abstraction needs to be created such that the device behaves like a combinational circuit. 

\subsection{Platform dependence}
Earlier approaches that have applied FPGAs in education have resulted in solutions that are very board-specific. FPGAs manufactured by both Xilinx and Altera have been allied in the education of these topics. Both manufacturers have tightly integrated their software development kits with their FPGAs. Development board are manufactured by these manufacturers, as well as third parties, such as Digilent. 

Hardware design projects may be interchangeable between different versions of a FPGA chip, as well as different product families.

\subsection{Programming}
Current FPGAs generally make use of the IEEE 1532 standard for in-system programming, which extends the IEEE 1149.1 'JTAG' boundary scan protocol. In order to program these FPGAs, one makes use of dedicated JTAG programming hardware and software. Such hardware and software is commonly available.  

FPGA development board manufacturers generally integrate JTAG programming hardware in their designs, allowing progamming over a serial connection to their PC, such as USB. Manufacturers combine their development boards with software development kits that facilitate the operating system drivers and software required for the programming process. Other means of programming are seen as well, such as support for USB storage devices or memory cards on which a file is placed that is automatically read by the development board and programmed onto the FPGA. FPGA development boards generally feature a JTAG interface as well, allowing for a custom method of programming using external tools. 

\subsection{PC Communication}
In order to allow for communcation with a PC, FPGA development board manufacturers generally include one or more communication interfaces in their board designs. Many FPGA development boards currently available come with a USB interface over which a virtual serial interface is exposed, commonly known as a virtual COM port. The serial signal is often controlled by a UART implementation that is programmed onto the FPGA. Other examples of communcation interfaces are RS232 and Eternet ports, where dedicated hardware components on the FPGA development board are responsible for translating signal levels controlled in the FPGA to interface standard levels. 

TODO uitleggen waarom synchronous sequential logic niet werkt op FPGAs. Timing sensitive, zeer geavanceerde place \& route. Wordt niet ondersteund door tools. 

% FPGA
% Eductional
% Computer architecture
% PC
% Instruction level view
% MIPS 

% Introduction
% Problem description
% Related work
% Educational softcores
% 
% FPGA fundamentals
% - toolchain
% 

\chapter{Model}

% TODO Toto: verdient een introductie. waarom ga je het model in stages opbouwen? waarom wordt er een limiting factor gezien? 
% TODO Duidelijkere verwijzing naar problem statement. Een uitgewerkte problem statement is ook een goed idee.

This chapter will propose a model that provides a theoretical solution to the problem statement as described in section \ref{sectionproblemstatement}. This model addresses the problem statement from a technical and architectural point of view, as well as how user processes are affected. As a starting point, a description of a basic model for experiment setups on FPGA development boards is given in section \ref{sectionbasicmodel}, which is then extended and modified through a series of stages. In every stage, a particular aspect of the problem statement is addressed, forming a complete solution eventually. 

In section \ref{sectionvirtualizingio} the possible limiting factor of the  number of I/O devices on the FPGA development board is addressed by introducing the concept of a controller. This controller provides the experiment setup logic with a variable amount of virtual I/O channels. The levels of these I/O channels can then observed and controlled through controller-specific PC software. All of the physical I/O devices are temporarily removed from the model, as well as most of the FPGA's other peripheral devices.

In section \ref{sectioncyclecontrol} the controller is extended such that it allows for cycle-accurate control of sequential experiment setup logic. Users control cycles through the PC software, but the model supports autonomous operation as well. This new functionality is added through expansion of the experiment setup interface.

In section \ref{sectioncontrollerabstraction} the experiment controller's interface is generalized, such that the interface dependencies between experiment setup and controller are removed. This allows for independent development of controllers and experiment setups, allowing for random combinations of board-specific controllers and independent experiment setup logic. The controller's PC interface is generalized as well, which allows for the development of universal PC software.

In section \ref{sectionreintroducingio} the FPGA development board's physical I/O devices are reintroduced into the model, after being removed from the model in section \ref{sectionvirtualizingio}. This step is essential in enabling a student's physical view of the experiment setup and providing a hands-on experience. The development of experiment setups remains an independent process.



\section{The Basic Model}
\label{sectionbasicmodel}

% TODO er worden een aantal zaken gepresenteerd waarvan een verwijzing ontbreekt. Hoewel er geen 1-1 verwijzing is in een aantal gevallen, kun je wel verwijzen naar de stukken op basis waarvan de gepresenteerde informatie is dedistileerd. 

% TODO in figuren en tekst onderscheid maken tussen I/O, HID, peripheral, communication device.

As a starting point, a description of a basic model for experiment setups on FPGA development boards is given. An overview of the basic model is displayed in figure \ref{fig:overview-basic}. The model features a PC and a FPGA development board as the two primary physical components. An interface between the PC and the FPGA development board exists over which the board exposes the \texttt{Board.Program()} operation. This operation initializes the FPGA by loading the contents of a FPGA-specific bitstream file and configuring the FPGA's components. The physical and electrical characteristics of this interface are considered to be irrelevant and may even be a process that involves manual user operations, such as transferring a memory card.


\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{img/overview-basic}
\caption{The basic model, an overview of the FPGA development board and its exposed interfaces.}
\label{fig:overview-basic}
\end{figure}

In this basic model, the FPGA development board is considered to be a printed circuit board (PCB) which hosts and interconnects a FPGA and its various peripheral components. Not all pins of the FPGA package and not all peripheral devices are considered to be relevant to the model. Only the pins whose signals can be controlled through the FPGA's contained logic are included. Peripheral devices that do not connect to these pins, such as power supplies or programming circuits are excluded from the model. Specifically, the presence of a clock generating device is assumed, providing the FPGA with a clock signal on one of its pins. Although this model is a great simplification of reality, this abstract view is assumed to be sufficient for the purposes of this model and applicable to most FPGA development boards. 

Besides the omission of details of the FPGA's peripherals, a part of the FPGA's internal complexities are hidden from the model as well. Figure \ref{fig:fpga-basic} gives a graphical overview of the FPGA's internals and its contained logic. The FPGA's internal interface is simplified and defined to be a container for the end product of a HDL developer's work: an entity with input signals, output signals and an input clock signal. Other physical, electrical or logical characteristics of the FPGA are not included in the model.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{img/fpga-basic}
\caption{The basic model, an overview of the FPGA and its contained experiment setup logic. No specific architecture is applied to the logic.}
\label{fig:fpga-basic}
\end{figure}

In the case of this basic model, no specific architecture is defined that will embed the experiment setup logic into the FPGA development board. A specific architecture will be developed in the following stages. At this stage of the model, a developer is responsible for the development of its own architecture that embeds the experiment setup logic into the environment of the FPGA.

In this basic model, two user roles are defined: experiment setup developers and experimenters. In a classroom environment, an instructor can be considered an experiment setup developer and a student can be considered an experimenter. 

\subsection{Experiment Setup Developers}
\label{sectionexperimentdevelopers}
Experiment setup developers are responsible for the design, implementation, testing, documentation and distribution of experiment setups for use on FPGA development boards. The end product of their work is a software package that contains a bitstream file and optionally the source files used in the bitstream file's compilation process. Figure \ref{fig:process-development-basic} displays a graphical overview of the experiment setup development process. 

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{img/processes-basic-development}
    \caption{The basic model, an overview of the experiment setup development process.}
    \label{fig:process-development-basic}
\end{figure}


% TODO onderstaande opsomming is beter op zijn plaats in de problem statement.
As shown below, an experiment setup developer must have knowledge of a significant number of subjects and technologies: 

\begin{itemize}
\item Designing an experiment setup requires knowledge on the subject of digital logic and digital systems. 
\item For the design to contain meaningful educational content, the developer should have experience in teaching the subject. 
\item Translating the design into a working, valid implementation in VHDL or Verilog requires experience in HDL development.
\item Embedding the implemented design in a FPGA development board requires knowledge of the specific FPGA, its development tools and the FPGA's peripheral devices.
\end{itemize}

\subsection{Experimenters}

Experimenters are responsible for carrying out experiments. They obtain experiment setup software packages and initialize experiment setups on their FPGA development boards. In order to complete the experiment, they make observations and interact with the experiment setup that is contained within the FPGA. Figure \ref{fig:process-experimentation-basic} displays a graphical overview of the experimentation process. In this basic model, two different methods of interaction are defined: interaction through board I/O devices and interaction through the process of HDL source modification, recompilation and reprogramming. Observation of the experiment's results can be done through the FPGA development board's I/O devices. Some development tools allow for live inspection of the FPGA's internal signal levels through a PC connection.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{img/processes-basic-experimentation}
    \caption{The basic model, an overview of the experimentation process.}
    \label{fig:process-experimentation-basic}
\end{figure}

In order for a user to act as an experimenter, one must understand the logic and workings of the obtained experiment setup. Furthermore, an experimenter must understand the basic concepts and role of the FPGA development board, as well as how to program the FPGA via the experimenter's PC. In preparation of the experiment, experimenters must install programming software and operating system drivers for the FPGA development board. In this case, interaction and observation is done through the board's I/O devices. 

Including the PC as a tool for observation and interaction requires additional knowledge and preparation from experimenters. In order to understand and modify the experiment setup's HDL sources, users must be familiar with the programming language used. Recompilation requires users to install and understand the FPGA's development tools in order to set up a proper development environment. Furthermore, this method of interaction will significantly increase the time required for every change to be processed, since the process of recompilation is a slow process. Using the FPGA as a tool for observation requires further familiarization with the FPGA's development tools.







\section{Virtualizing I/O}
\label{sectionvirtualizingio}

% TODO In deze sectie verduidelijken dat state control nog niet mogelijk is en dat interne state alleen inzichtelijk kan worden gemaakt door expliciet signalen naar buiten te brengen in het experiment ontwerp.

% TODO Er wordt een externe user interface gepresenteerd als oplossing. Hoe ziet deze er uit?

% TODO: Toto: zijn er geen downsides van het gebruik van software?

Regular FPGA development boards offer a limited set of I/O devices. As a consequence, this allows for observation and control of experiment setup logic entities with a limited number of input and output signals. Embedding entities with a large number of inputs and outputs however, requires a different approach. 

In order to support experiment setup entities with a large number of input and output signals, the basic model's logic architecture is extended through introduction of the controller. Figure \ref{fig:fpga-inout} gives an overview of the FPGA and the newly defined architecture. The experiment setup entity's inputs and output signals are available to the controller only, but both components still share a common clock signal. The signal levels of the FPGA's peripheral devices are no longer driven by the experiment setup entity. Following the previous section's criteria, these devices are considered irrelevant and thus removed from the model. Only the clock generating device and a single machine-machine communication device remain part of the model. 


\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{img/fpga-inout}
\caption{I/O virtualized, an overview of the FPGA and its contained logic architecture. The controller embeds the experiment setup logic into the FPGA.}
\label{fig:fpga-inout}
\end{figure}

% Concept controller ook te zien in \cite{jansen2014every}

The controller is a component that acts as an intermediary between the experiment setup logic and an experimenter's PC. The experiment setup's state is observed and controlled through controller-specific software, a method also presented in \cite{holland2003harnessing} and \cite{bulic2013fpga}. A hardware-based method to observe and control the experiment setup's state is described in \cite{al2007teaching}. A software-based solution however, does not increase the cost of the experiment. Furthermore, a software-based approach will allow for more flexibility, as shown in the following sections. 

The controller exposes an additional interface through a communication channel that must be provided by one of the FPGA development board's communication devices, as can be seen in figure \ref{fig:overview-inout}. This interface defines operations that allow for the experiment setup entity's individual input and output signals to be controlled and observed respectively. A similar interface for observation and control of specific signals is described in \cite{holland2003harnessing}. 

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{img/overview-inout}
\caption{I/O virtualized, an overview of the FPGA development board and its exposed interfaces.}
\label{fig:overview-inout}
\end{figure}

The explicit separation of concerns in the logic architecture allows for separate implementation and validation processes for experiment setup logic, controller logic and PC software. This partitioning subsequently allows for distribution of work among specialists, removing the need for a single experiment developer to have knowledge and experience in all the areas previously described in section  \ref{sectionexperimentdevelopers}. As a consequence of the separation however, more dependencies are introduced into the development process. The development of a controller component requires a definition of the experiment setup's interface and any change in this interface definition requires modification of the controller. A similar dependency exists between the controller and the PC software. A change in the experiment setup entity's interface definition will thus not only result in the need for modification of the controller, but in the need for modification of the PC software as well. These dependencies are addressed and removed from the model in section \ref{sectioncontrollerabstraction}.

Experiment setup interaction through dedicated PC software will simplify the experimentation process for experiment setups with large number of input and output signals. Involving the PC removes the need for experimenters to install and familiarize themselves with the FPGA's development tools. Experimenters will be able to interact with the experiment setup through a graphical interface on the PC, removing the need need for HDL programming skills and allowing for real-time interaction, since no recompilation is required. Since the board's I/O devices have been removed at this stage of the model, there is no possibility for users to physically interact with the experiment. The PC software provides the only means of interaction with the experiment setup. These removed I/O devices however, will be reintroduced into the model in section \ref{sectionreintroducingio}.

% TODO Hoe ziet de PC software er uit?



\section{Cycle control}

% TODO: Taco: Toch eens onderzoeken wat voor mogelijkheden clock domains bieden, mogelijk beschrijven in chapter background.

% TODO: Timing diagram ter verduidelijking clock_enable

\label{sectioncyclecontrol}
In the previous section, the basic model has been extended to include a definition of the controller. This controller allows for the embedding of experiment setup entities with an arbitrary number of input and output signals that are defined through combinational logic. FPGAs in general lack practically useful support for containment of asynchronous sequential logic, but the availability of a clock signal in the current model does provide support for experiment setup entities that are defined through synchronous sequential logic. However, this clock signal is constant and cannot be varied in speed or temporary stopped. Embedding an experiment setup entity of synchronous sequential logic at this stage of the model would result in an uncontrollable situation of continuous state changes at high speed. This limited control over the clock signal is due to the nature of how FPGAs work and prevents cycle-accurate interaction with the experiment setup. In order to be capable of cycle-accurate observations and control over synchronous sequential experiment setup logic, the model requires further extension.

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{img/fpga-control}
\caption{Cycle control, an overview of the FPGA and its contained logic architecture. The \texttt{clock\_enable} and \texttt{reset} signals are added to allow for cycle-accurate interaction and (re)initialization.}
\label{fig:fpga-control}
\end{figure}

As a solution to the problem stated above, the FPGA's contained logic architecture has been extended, as displayed in figure \ref{fig:fpga-control}. The most significant change is the addition of the \texttt{clock\_enable} input signal on the experiment setup's interface definition. Combined with the \texttt{reset} signal, these new input signals allow for cycle-accurate control and reinitialization of the experiment setup logic's state. The introduction of the \texttt{clock\_enable} signal will require modification of every synchronous memory element present in the experiment setup logic, as displayed in figure \ref{fig:clock-manipulation-enable}. By multiplexing the input signal for every memory element based on the same \texttt{clock\_enable}, one can control the state change in a cycle-accurate manner. The method of using enable signals to control synchronous logic is described in \cite[Sec 2.4.5]{arora2011art}.

One may argue that this approach is unfavourable, since it requires modification of existing experiment setup logic designs. This method for controlling state change however, is a common approach in FPGA-targeted HDL development and is used in many designs. More specifically, this approach was also taken in controlling the experiment setups described in \cite{holland2003harnessing} and \cite{bulic2013fpga}. As stated before, FPGAs do not allow for dynamic manipulation of clock signals by design, a method known as clock gating (figure \ref{fig:clock-manipulation-gated} ). Clock signals are distributed over the FPGA through dedicated lines that cannot be altered through HDL logic. Some manufacturers include support for static clock division, but still only down to relatively high speeds and do not allow for dynamic adjustment of clock speed [TODO: Bron]. 

% TODO: Opmerking Taco 
% Opmerking bij fig 3.8 discussie. Het board dat je gebruikt is een artix7
% en die familie (d.w.z. de "7" familie van xilinx) gedraagt zich anders. Er kunnen verschillende clockdomeinen gebruikt worden en dan
% heb je wel degelijk een soort van gated clock, hoewel dat nooit gebeurt via clk_gated = clk_org &
% enable. Lees het 7 series fpga clocking resources user guide document van xilinx!

% TODO: Toto: Meer uitleg bij deze figuren

\begin{figure}[h]
    \centering
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[height=1.5in]{img/clock-manipulation-gated}
        \caption{Gated clocks}
        \label{fig:clock-manipulation-gated}
    \end{subfigure}%
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[height=1.5in]{img/clock-manipulation-enable}
        \caption{Enable signal}
        \label{fig:clock-manipulation-enable}
    \end{subfigure}%
    \caption{Controlling state transitions through a clock enable signal and a gated clock signal. FPGA's do not support gated clock signals.}
    \label{fig:clock-manipulation}
\end{figure}

In order to make this newly developed functionality available to the experimenter through the PC software, the controller interface is extended to support new operations that allow for the control of cycles. As displayed in figure \ref{fig:overview-control}, five new operations are available through the controller's interface. The \texttt{Controller.Reset()} operation (re)initializes the experiment setup to it initial state and waits for the next operation. Experimenters have manual control over the experiment setup's cycles through the \texttt{Controller.Step()} operation. The controller may also be instructed to manage the experiment setup autonomously through the \texttt{Controller.Start()} operation. The maximum operating frequency may be defined through the \texttt{Controller.LimitSpeed()} operation. The \texttt{Controller.Stop()} operation stops the controller's autonomous management of the experiment setup and awaits the next operation. Similar interfaces for cycle-accurate control of experiment setups are described in \cite{holland2003harnessing} and \cite{bulic2013fpga}.

\begin{figure}[h!]
\centering
\includegraphics[width=\textwidth]{img/overview-control}
\caption{Cycle control, an overview of the FPGA development board. The controller's interface is extended with operations that allow for cycle-accurate interaction with the experiment setup.}
\label{fig:overview-control}
\end{figure}



% TODO: Students must be able to disconnect from the PC and consider the setup as an autonomous entity. The controller interface needs to be extended with a PLAY/PAUSE instruction as well as a means to set the experiment setups clock speed. There needs to be the distinction between a slave mode when connected to the pc as well as a autonomous mode when disconnected.


% \subsection{FPGA Clock management}
% FPGAs generally run on a single clock signal. On modern FPGAs, this clock signal has a frequency in the order of megahertz, which would result in the execution of the experiment at millions discrete steps per second. This clock is generally fixed. In order for students to be able to control their clock speed or even pause their experiment for observations, a second signal must be introduced into the experiment, allowing the enabling of a clock signal. By enabling this 'clock enable' signal for the duration of one clock cycle, the experiment progresses one discrete time step. A disadvantage of this approach is that experiments must be adapted to support this method of managing clocks. This approach however is commonly seen in industry IP components.

% DCM is unsuitable, because it does not allow for halting of the clock signal as well as running on very low frequencies.

% Experiments requiring async clocks can fake this behaviour by deriving a 'clock enable' using a counter.

% See figure \ref{fig:fpga-control}.







\section{Board Component Abstraction}
\label{sectioncontrollerabstraction}

% TODO: Taco: Hoe ga je de inhoud van complexe memory devices inzichtelijk maken?

% TODO: Taco: Wordt de experiment setup adapter gegenereerd?

% TODO: Taco gaat er van uit dat de experiment setup adapter de top component is.

% TODO: Taco: Uiteindelijke functionele omschrijving controller ontbreekt nog

% At this stage of the model's development, it supports the embedding of experiment setups defined through combinational logic as well as synchronous sequential logic. Experimenters can interact with these experiment setups through PC software that is specifically developed for the experiment setup. 
While the model has developed to address a number of problems encountered by experimenters, the problems experienced during development have only been addressed partially. Although an architecture for the FPGA's contained logic was developed in the previous sections, a series of dependencies can still be identified in the development process, as displayed in figure \ref{fig:dependencies-control}.  

The source of these dependencies is the interface between controller and experiment setup. This interface is specific for every experiment setup. By defining a standard interface between experiment setup and controller, this dependency is removed. In the current approach, the experiment setup is considered an entity with inputs and outputs, supplemented by a clock signal, a clock\_enable signal and a reset signal. 

\subsection{Address Space}
%TODO zinnen verbeteren, nog redelijk vaag
% TODO waarom is de keuze voor het model van een address space een goede keuze?
In order to be able to provide a generic interface between controller and experiment setup logic, the experiment setup's interface is modified such that it resembles the interface of a block ram, as can be seen in figure \ref{fig:interface-experiment}. The experiment setup's signals are projected on the address space. 

Losing the information about which signal is which is irrelevant to proper operation of the controller. In order for the PC software to be of any practical use however, a definition of this memory space is required, such that the individual signals can be identified from the memory space. 

The controller does no longer provide an interface to the experiment setup, but acts as a proxy to control the experiment setup's interface. This does not only allow for a reuse of controlling logic, but a simplification as well, since the interface that is exposed to the controller is simplified as well.

\subsection{Interface}
% TODO waarom is een BRAM interface een goede keuze?
%  - eenvoud
% TODO wat zijn de verschillen/voordelen/nadelen t.o.v. andere businterfaces zoals wishbone, AXI etc.
% - wishbone zou een goede optie kunnen zijn ivm open source
% - hoge leercurve bus interfaces
% - master slave interface is voldoende
% - bus interfaces zijn vaak nodeloos complex
% - begrip interface is wijdversprijd
% - ik had niet de capaciteiten om uitgebreid de mogelijke aanvullende voordelen van een businterface te bestuderen, terwijl deze interface voldoende biedt.

\begin{figure}[h]
    \centering
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[height=1.2in]{img/interface-bram}
        \caption{Single-port block ram, derived from \cite{RAMs68}}
        \label{fig:interface-bram}
    \end{subfigure}%
    \begin{subfigure}[t]{0.5\textwidth}
        \centering
        \includegraphics[height=1.5in]{img/interface-experiment}
        \caption{Experiment setup interface}
        \label{fig:interface-experiment}
    \end{subfigure}
    \caption{Interfaces}
    \label{fig:interfaces}
\end{figure}


\subsection{Memory devices}
%TODO sectie verbeteren, nog erg vage zinnen.

The experiment setup has been considered to be an entity with input output signals. Any memory elements contained within the experiment setup can be made accessible through these input and output signals. This solution is not very scalable however. In order to allow for the controller to read and write to large memory elements such as block rams and register files, a different solution is required. A solution to this problem is displayed in figure \ref{fig:logic-wrap-extended}. 

A simple wrapper can be computer-generated in many cases. If complex memory devices are contained within the experiment setup, a wrapper can be defined manually, using an experiment setup adapter component, address space splitters and memory interface multiplexers. 

Large memory elements such as register files and block rams may be defined in HDL. During the compilation process, these elements are infered from HDL code and the FPGA's internal block rams are used. 

% If more memory space is required however, external memory devices such as DDR RAM IC's may be required. Since these external RAM devices require a number of cycles in order to accress the data, they must be abstracted in order to be accessible from within the experiment setup logic. In order to achieve the desired effect of seeing these DDR RAM devices as block ram devices that only require a single clock cycle to operate, the controller must stall the \texttt{clock\_enable} signal until the DDR controller finishes the desired operation. 


\subsection{Composition Process}
In stead of the distinction between controller and experiment setup, a new separation is defined in the controller's logic architecture. A distinction is made between the logic that is targeted to a specific FPGA development board and the logic that targets the standard board component interface. Figure \ref{fig:fpga-abstract} displays this distinction. This distinction is made, because the experiment setup is no longer being defined by it's primary logic, but as secondary interfacing logic as well. 

% The controller was defined to be a specific implementation embedding a specific experiment setup into a FPGA development board.

\begin{figure}[h]
\centering
\includegraphics[width=.8\textwidth]{img/fpga-abstract}
\caption{Controller abstracted, FPGA logic design}
\label{fig:fpga-abstract}
\end{figure}

A new process is defined for the composition of board component and experiment setup component into a bitstream file. This results in the processes of experiment setup development and board component development to become independent. Figure \ref{fig:dependencies-abstract} displays the composition process and its relation to the  development processes for experiment setup component and board development component in terms of dependencies. 

\subsection{Experiment Setup Adapter}

In order for an experiment setup logic to conform to the experiment setup component's interface, a component is introduced that acts as an adapter. This experiment setup adapter is a logic component that projects the experiment setup's input and output signals onto an address space. Figure \ref{fig:fpga-abstract} displays the experiment setup adapter.




\subsection{Generic PC Software}
A major advantage of the generic interface between the controller and experiment setup is that PC software can be developed that is no longer specifically tied to one particular experiment setup design. The controller now acts as a proxy between the PC and the experiment setup. The experiment setup is considered an address space from the PC software, no longer an entity with inputs and outputs. In order for this address space to be of any significant meaning, the PC software requires information on how the data in this address space is structured. During the wrapping process a file will be generated, describing how the experiment setup's signals are projected onto its address space. 

% iets zeggen over de faciliterende interface tussen PC en 



\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{img/overview-abstract}
\caption{Controller abstracted, overview}
\label{fig:overview-abstract}
\end{figure}


%variable address width
%variable data width

% studenten:
% - nog niet mogelijk snel te switchen
% docenten
% - afhankelijkheden tijdens ontwikkelproces.

% het is nog niet mogelijk te interfacen met complexe state devices in 

% Developed experiment setups are still board-specific

% Software is still controller-specific

% Controller-specific software

% Experiment-specific controller

% abstraction Allows for reuse of code

% abstraction allows for board-independent experiment development

% abstraction allows for random combination of experiment and controller, allowing for reuse of experiment code

% introduction of standard interfaces removes dependencies from development process

% Removing the dependency from controller to experiment, generic interface.

% Allows for reuse of generic board components for different experiment setup components.

% Complicates experiment development, but process of wrapping can be automated

% view of experiment as address space allows for easy interface from software address space allows for projection of signals as well as memory elements.









\section{Reintroducing Board I/O}
\label{sectionreintroducingio}

Experiment setup has no accurate notion of time, so I/O devices can only be addressed as combinational devices. I/O device drivers facilitate this.

Board I/O capabilities are of vital iportance in providing a physical hands-on experience. Although the FPGA itself is a physical object, the board's I/O capabilities expose the hardware setup's physical behaviour and provide real life interaction capabilities. Without this step, the whole point of a physical hands-on experience is lost.

See figure \ref{fig:fpga-io}

\subsection{I/O processing}
Optionally, one needs to introduce device driver logic in order to allow for sequential I/O device logic to be usable as combinational logic. 




\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{img/overview-io}
\caption{I/O reintroduced, overview}
\label{fig:overview-io}
\end{figure}


\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{img/fpga-io2}
\caption{I/O reintroduced, FPGA logic design}
\label{fig:fpga-io}
\end{figure}

% \begin{figure}
% \centering
% \includegraphics[width=\textwidth]{processes-dependencies-io}
% \caption{I/O reintroduced, Process dependency graph}
% \label{fig:processes-dependencies}
% \end{figure}

% \begin{figure}
% \centering
% \makebox[\textwidth][c]{\includegraphics[width=1.25\textwidth]{processes-io}}
% \caption{I/O reintroduced, Processes overview}
% \label{fig:processes-io}
% \end{figure}

% \section{Student Requirements}
% A FPGA development board is connected to a student's PC. Two issues need to be addressed: an easy way of programming the FPGA in order to setup the experiment and communication with the FPGA to allow for interaction during the experiment. 

% Manufacturer development tools often facilitate these functions.

% They install FPGA board operating system drivers and experiment host software. An experiment is prepared by the course instructors and distributed to students. By loading the experiment, the fpga should be automatically programmed. The FPGA is not reprogrammed during the experiment. The student only interacts with the experiment through the experiment host software or the physical board as if it were the experiment hardware itself. 

% \section{Instructor requirements}
% It should be easy for instructors to create, test and distribute experiments. For the development of these experiments, instructors should be able to make use of existing development tools. 

% \section{Conceptual Model}
% In combinatorial logic, the output of signals is not dependent on the state of the digital circuit. In sequential logic, the output is dependent on the input signal levels, as well as the levels of previous input signals, the state of the circuit. Sequential logic is usually synchronous, meaning that state changes are triggered by a clock signal. 

% The circuit's state needs to be transfered to the student's PC such that it can be interpreted. 

% From an abstract point of view, a sequential circuit's state can be seen as a series of signals. Some signals are singular bit values, while others are composed of multiple bit values. Signals can be independent, while similar may be grouped by function, such as a set of cpu registers, data memory or instruction memory. 

% All these signals may be projected onto a memory space in order to allow for all signals of an experiment setup to be represented uniformly. 

% A file combined with the fpga program instructs the PC software on how to the memory space should be interpreted. This file is specific for one single version an FPGA program, but the same accross different FPGA board and desktop tools. In the fpga program it is determined how the experiment's signals are mapped onto the memory space. The PC software interprets these signals. 

% A fpga program may support multiple types of communication, such as serial rs232, ehternet, pci express etc...

% A distributable is specific for a combination of a FPGA development board model, a version of the FPGA program and a version of the PC tools. 

% The pc software must allow for the loading of a distributable, programming the experiment onto the FPGA and establishing a connection such that it can control the experiment. The PC software interprets the memory map of the fpga program and adapts its interface. After establishing a connection, the student can start the experiment by manually stepping a clock cycle, or set the clock cycle to increase automatically at a defined frequency. 

\chapter{Implementation}
In order to test the proposed framework, an implementation is provided. The framework implementation is targeted at the Digilent Nexys 4 FPGA development board, displayed in figure \ref{fig:nexys4}. This board contains a Xilinx Artix-7 series FPGA and is equipped with various I/O devices. The development board is connected with the PC through USB. This USB connection is used in order to setup a serial communication channel between the PC and the FPGA.

\begin{itemize}
\item PC Software Interface Standardization
\item PC Software Development
\item FPGA Development Board PC Software Plugin Development
\begin{itemize}
\item For a specific FPGA Development Board PC Driver
\end{itemize}
\item Board Package Interface Standardization
\item Board Package Development
\begin{itemize}
\item For a specific FPGA Development Board
\end{itemize}
\item Experiment Wrapping Toolchain Development
\item Composition Toolchain Development
\begin{itemize}
\item For a specific FPGA Compilation Toolchain
\end{itemize}
\item Experiment Setup Development
\end{itemize}


\section{Functional}
Reset button behaviour.

\begin{figure}
\centering
\includegraphics[width=0.7\textwidth]{img/nexys4-small}
\caption{Digilent Nexys 4 Artix-7 FPGA development board}
\label{fig:nexys4}
\end{figure}

\chapter{Experimental results}

\appendix

\chapter{Process Analysis}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{img/processes-dependencies-basic}
\caption{The basic model, process dependency graph}
\label{fig:dependencies-basic}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=\textwidth]{img/processes-dependencies-inout}
\caption{I/O virtualized, process dependency graph}
\label{fig:dependencies-inout}
\end{figure}

\begin{landscape}
\begin{figure}
\centering
\includegraphics[width=\hsize]{img/processes-dependencies-control}
\caption{Cycle control, process dependency graph}
\label{fig:dependencies-control}
\end{figure}
\end{landscape}

\begin{landscape}
\begin{figure}
\centering
\includegraphics[width=\hsize]{img/processes-dependencies-abstract}
\caption{Controller abstracted, process dependency graph}
\label{fig:dependencies-abstract}
\end{figure}
\end{landscape}

\begin{landscape}
\begin{figure}
\centering
\includegraphics[width=\hsize]{img/processes-dependencies-io}
\caption{I/O reintroduced, process dependency graph}
\label{fig:dependencies-io}
\end{figure}
\end{landscape}





\chapter{Logic Diagrams}

\section{Simple wrapping}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{img/logic-wrap-simple}
    \caption{Caption}
    \label{fig:logic-wrap-simple}
\end{figure}

\begin{landscape}
    \section{Advanced wrapping}
    \begin{figure}[h]
        \centering
        \includegraphics[width=\hsize]{img/logic-wrap-extended}
        \caption{Complex wrapper}
        \label{fig:logic-wrap-extended}
    \end{figure}
\end{landscape}

\section{Experiment Adapter}
\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{img/logic-wrap-simple}
    \caption{Caption}
    \label{fig:logic-experiment-adapter}
\end{figure}

\cleardoublepage

\addcontentsline{toc}{chapter}{Bibliography}
\phantomsection

\printbibliography

\end{document}