\documentclass[main.tex]{subfiles}
\begin{document}

\chapter{Implementation}
In order to support the proof of concept for the proposed model, a number of the model's parts have been implemented:
\begin{itemize}
    \item Experiment setup package specification
    \item Experiment setup wrapper
    \item Board package specification
    \item Digilent Nexys 4 Board Package
    \item Package composer
    \item Experimenter shell
\end{itemize}


\section{Experiment Setup Package Specification}
\label{section:experiment-setup-package-specification}
A format for experiment setup packages has been defined. For the purposes of portability, a \texttt{.zip} archive is used as a means for containment of all associated files. A manifest file describes the contents of the package and provides machine-readable instructions for any dependent tools. This approach to packaging was derived from other packaging methods, such as java \texttt{.jar} packages. Figure \ref{fig:experiment-setup-package-filesystem} displays an overview of the experiment setup package file structure. The name and location of the manifest file is constrained by the specification, but the names and structure of other files contained in the package are not limited by any constraints.

\begin{figure}[h]
\centering
\caption{An overview of the experiment setup package file structure}
\label{fig:experiment-setup-package-filesystem}
\begin{subfigure}[b]{0.4\textwidth}
\dirtree{%
.1 package.zip.
.2 directory/.
.3 directory/.
.4 \dots.
.3 source file. 
.3 \dots.
.2 source file. 
.2 \dots.
.2 mainfest.yaml. 
}
\end{subfigure}
\end{figure}

The manifest file describes the contents of the experiment setup package and its information is encoded in \texttt{YAML}\footnote{http://yaml.org/} syntax. Besides package metadata, such as title and author information, the manifest also contains file pointers and a description of the experiment setup's address space. Furhermore, the manifest defines the widths for the address and data buses. An example experiment setup package manifest is displayed in listing \ref{lst:experiment-setup-package-manifest}. In automated processes, this manifest file is generated by the experiment setup wrapper, as described in section \ref{section:experiment_setup_wrapper}.

\begin{lstlisting}[caption={Example experiment setup package \texttt{manifest.yaml}}, label={lst:experiment-setup-package-manifest}]
type: experiment-setup-package
version: 1
title: Full Adder using Half
description: >
    An implementation of a full adder using two half adders.
author: Matthijs Bos
date: (*@ \today @*)
url: https://github.com/matthijsbos/fulladderhalf/
files: 
    - ./wrapper.vhd
    - ./fulladder.vhd
    - ./halfadder.vhd
topLevelFile: ./wrapper.vhd
addressWidth: 3
dataWidth: 1
addressSpace:
    - { name: a,    direction: in,  addr: 0x0, width: 1 }
    - { name: b,    direction: in,  addr: 0x1, width: 1 }
    - { name: cin,  direction: in,  addr: 0x2, width: 1 }
    - { name: s,    direction: out, addr: 0x3, width: 1 }
    - { name: cout, direction: out, addr: 0x4, width: 1 }
\end{lstlisting}






\section{Experiment Setup Wrapper}
\label{section:experiment_setup_wrapper}
A PC software tool has been developed to facilitate the model's experiment setup wrapping process. The experiment setup wrapper has been implemented using the Java 8 programming language and its source code is included in appendix \ref{chapter:fpga-edu-wrapper-sources}. This tool takes an existing VHDL implementation and a user-defined configuration file in order to generate an experiment setup package, as shown in figure \ref{fig:wrapper-overview}. 

\begin{figure}[h]
    \centering
    \includegraphics[width=0.7\textwidth]{img/wrapper}
    \caption{An overview of the experiment setup wrapper operation}
    \label{fig:wrapper-overview}
\end{figure}

Listing \ref{lst:wrapper-configuration} displays an example wrapper configuration file. This file contains contains pointers to the VHDL files that define the experiment setup's implementation as well as a pointer to the file that contains the implementation's top-level module. Additionally, the configuration file is also used to specify experiment setup metadata which is written into the experiment setup package's manifest file. 

\begin{lstlisting}[caption={Example \texttt{fpgaedu.yaml} wrapper configuration file for a simple 8-bit counter implementation.}, label={lst:wrapper-configuration}]
title: 8-bit counter
description: A simple 8-bit counter with an enable signal.
url: https://github.com/matthijsbos/count8
files: 
    - ./counter.vhd
topLevelFile: ./counter.vhd
\end{lstlisting}

A number of steps can be identified in the process of wrapping an existing experiment setup implementation. First the configuration file is read in order to obtain a pointer to the implementation's top-level file, which is then read and parsed. A VHDL parser was generated using the ANTLR4 language tool\footnote{\url{http://www.antlr.org/}}, for which a comprehensive VHDL grammar description was already available \footnote{\url{https://github.com/antlr/grammars-v4}}. After parsing the top-level file, information is extracted from the entity so that it can be used for generating a VHDL file that replaces the top-level file and provides an interface between the experiment setup's signals and the controller's memory interface. 

\subsection{Address Space Projection}
In order to allow for signal interaction through an address space, the experiment setup's signals are to be projected on that address space. A distinction can be made between experiment setup input signals, which can be read from and written to from the address space, and experiment setup output signals, which can only be read from the address space. The address space is partitioned to provide every experiment setup signal with its own partition of this address space, such that these signals are uniquely addressable. 

TODO implementation not finished yet


\subsection{Limitations}
Due to the complexities of the VHDL language, support for a number of language features has been omitted. Although there is no limit on the number of ports, entity port types are limited to be of \texttt{std\_logic} or big-endian \texttt{std\_logic\_vector}, as defined in the \texttt{IEEE.std\_logic\_1164} package. Furthermore, no support for generic parameters has been included in the tool's implementation. Although these limitations may prove to be problematic in production environments, their effects are not considered to be relevant in establishing a proof of concept. These types are among the most commonly used and this limitation can be easily overcome through simple modifications of the top-level VHDL file. Signals between internal instances are not subjected to these limitations.


\section{Board Package Specification}
A format for board packages has been developed to facilitate the encapsulation and re-use of FPGA development board-specific logic. This specification is similar to the experiment setup package specification as described in section \ref{section:experiment-setup-package-specification}. The package's unit of containment is also a \texttt{.zip} file archive and has a file structure identical to that displayed in figure \ref{fig:experiment-setup-package-filesystem}. 

The board package manifest file contains information about the 

\begin{lstlisting}[caption={Example board package \texttt{manifest.yaml}}, label={lst:board-package-manifest}]
type: board-package
version: 1
title: Digilent Nexys 4 Board Package
description: >
    Board package for Digilent Nexys 4 FPGA Development Board. 
    PC communication via built-in USB port which emulates a
    RS232 connection.
author: Matthijs Bos
date: (*@ \today @*)
url: https://github.com/matthijsbos/nexys4boardpackage/
files: 
    - ./main.vhd
    - ./controller.vhd
    - ./uart.vhd
    - ./data-link.vhd
topLevelFile: ./main.vhd

\end{lstlisting}

\section{Digilent Nexys 4 Board Package}
A board package has been developed for the Digilent Nexys 4 FPGA development board. Figure \ref{fig:nexys4} displays the development board. The board's primary component is a member of the Xilinx Artix-7 family of FPGAs. The board features a number of peripheral devices that support human interaction and machine-to-machine communication. 

\begin{figure}[h]
\centering
\includegraphics[width=0.6\textwidth]{img/nexys4-small}
\caption{Digilent Nexys 4 Artix-7 FPGA development board}
\label{fig:nexys4}
\end{figure}

% \begin{figure}[h]
% \centering
% \includegraphics[width=\textwidth]{img/board-package-overview}
% \caption{An overview of the board package logic architecture.}
% \label{fig:board-package-overview}
% \end{figure}


\subsection{Communication Protocol}
A communication protocol has been designed to facilitate communication between the PC and the Controller embedded in the FPGA. When considering the OSI model as described in \cite[p.28]{tanenbaumcomputer}, the protocol exists in the physical and data link layers. Furthermore, an application layer has been defined. Since the communication channel is established on a point-to-point basis, any layers in between have not been considered relevant. 

\subsubsection{Physical Layer}

On the physical layer, the FPGAs peripheral devices facilitate a large part of the communication between the controller and PC. As described in \cite[p.9]{nexys4reference}, the Nexys 4 board features dedicated hardware for communication with the PC through a USB-UART bridge. A Rx and Tx line are available to specific FPGA pins and a virtual "COM" ports is made available on the user's PC. As part of the logic design embedded in the FPGA, a UART is implemented in order to receive data from and transmit data to the PC. Although the board features other means of machine-to-machine communication such as Ethernet, the approach involving UARTs was chosen for reasons of simplicity and compatibility. Many FPGA development boards available feature some means of serial point-to-point communication, either through physical RS232, or virtually through USB, Bluetooth, etc.

\subsubsection{Data Link Layer}

UARTs typically handle byte-sized units. In order to support the transmission and reception of larger units of data, a simple data-link layer has been implemented in order to define a data frame. To minimize the complexity of the implementation, the decision was made to provide an unacknowledged and  connectionless service, as described in \cite[p.177]{tanenbaumcomputer}. Although a production-oriented implementation might benefit from more robustness in the data-link layer, features such as frame acknowledgement and error detection have not been considered relevant in establishing a proof of concept. Due to the current implementation's adoption of the layered OSI model however, it should be possible to modify the data link layer to support these features. 

In order to identify individual frames of data, character stuffing \footnote{Also known as byte stuffing.} is used, as described in \cite[p.180]{tanenbaumcomputer}. Specific byte values are assigned to flag a frame's start and end. An escape character is used to prevent frame data to be identified as a control character. As in \cite{Frami37}, character \texttt{0x12} is used as a start flag, \texttt{0x13} as a stop flag and \texttt{0x7D} is used as escape character. Bytes are transmitted in big-endian order. Figure \ref{fig:character-stuffing} displays an example data frame.

\begin{figure}
\centering
\caption{Example data frame for transmission of six bytes: \texttt{0xA1}, \texttt{0xB2}, \texttt{0x12}, \texttt{0xB2}, \texttt{0x7D}, \texttt{0xB2}. The third and fifth byte are preceded by escape character \texttt{0x7D}.}
\label{fig:character-stuffing}
\includegraphics[width=.8\textwidth]{img/character-stuffing}
\end{figure}

\subsubsection{Application Layer}

On the application layer, a message format has been defined, similar to a processor's instruction set as described in \cite{hennessy2013computer}, for example. Messages have a fixed width and conform to be either an address-type or value-type message, as displayed in figure \ref{fig:message-formats}.  Both message types reserve their most significant byte position for the message opcode, a term commonly used in instruction sets to identify an instruction's desired operation. The two message formats suffice in covering the variations that exist in the different message types. Address-type messages are used to interact with the experiment setup's address space, while the value-type message format is used to describe the other operations. Both controller command and response messages use the same formats. 

\begin{figure}
    \centering
    \caption{Message formats for a controller with an address width of 32 and a data width of 8.}
    \label{fig:message-formats}    \begin{subfigure}[t]{\textwidth}
        \centering
        \caption{Address-type message format}
        \label{fig:message-format-address-typed}
        \includegraphics[width=0.75\textwidth]{img/message-format-address-typed}%
    \end{subfigure}
    \begin{subfigure}[t]{\textwidth}
        \centering
        \caption{Value-type message format}
        \label{fig:message-format-value-typed}
        \includegraphics[width=0.75\textwidth]{img/message-format-value-typed}%
    \end{subfigure}

\end{figure}

Tables \ref{tbl:opcodes-cmd} and \ref{tbl:opcodes-res} list the available opcodes for controller commands and responses respectively. The command opcodes have been chosen to reflect the operations that are exposed from the controller to the PC software. As can be observed from these tables, a large number of operations do not require to pass information as arguments. One might argue that a variable-length message format could have been more appropriate. In this implementation however, the decision was made to focus on simplicity and a fixed-length approach was taken to allow for simple message processing logic in the controller, since optimization is not a goal in establishing the proof of concept.

Some controller responses have a counterpart that is defined to indicate an error in the processing of the requested command. These errors represent the error of being incapable of executing the command due to the mode in which the controller is currently operating. The controller is incapable of executing the \texttt{Step (0x3)} command for example, when operating autonomously as the result of a previous \texttt{Start (0x4)} command. A response message with opcode \texttt{Step error (0x6)} would be returned in that case. 

\setlength{\tabcolsep}{8pt}
\renewcommand{\arraystretch}{1.2}

\begin{table}[h]
    \footnotesize
    \caption{Controller commands}
    \label{tbl:opcodes-cmd}
    \centering
    \begin{tabular}{|l|l|l|l|}
        \hline
        \textbf{Name} & \textbf{Opcode} & \textbf{Type} & \textbf{Arguments}    \\ \hline
        Read          & 0x00            & Address-type  & Address               \\
        Write         & 0x01            & Address-type  & Address, Data         \\
        Reset         & 0x02            & Value-type    & None                  \\
        Step          & 0x03            & Value-type    & None                  \\
        Start         & 0x04            & Value-type    & None                  \\
        Pause         & 0x05            & Value-type    & None                  \\
        Status        & 0x06            & Value-type    & None                  \\ \hline
    \end{tabular}
\end{table}
\begin{table}[h]
    \footnotesize       
    \caption{Controller responses}
    \label{tbl:opcodes-res}
    \centering
    \begin{tabular}{|l|l|l|l|}
        \hline
        \textbf{Name}  & \textbf{Opcode} & \textbf{Type}  & \textbf{Arguments}  \\ \hline
        Read Success   & 0x00            & Address-type   & Address, Data       \\
        Read Error     & 0x01            & Address-type   & Address             \\
        Write Success  & 0x02            & Address-type   & Address, Data       \\
        Write Error    & 0x03            & Address-type   & Address, Data       \\
        Reset Success  & 0x04            & Value-type     & None                \\
        Step Success   & 0x05            & Value-type     & Value               \\
        Step error     & 0x06            & Value-type     & None                \\
        Start Success  & 0x07            & Value-type     & Value               \\
        Start Error    & 0x08            & Value-type     & None                \\
        Pause Success  & 0x09            & Value-type     & Value               \\
        Pause Error    & 0x0A            & Value-type     & None                \\
        Status Success & 0x0B            & Value-type     & Value               \\ \hline
    \end{tabular}
\end{table}

\subsubsection{Message Format Parametrization}

An experiment setup's address and data buses have a variable width and the controller must thus match these specifications. While one experiment setup might require address and data buses of 2 and 1 bits wide respectively, another might require an address bus and data bus of 32 bits wide. Not only must the controller support scaling in order to support these changes, its message formats must be parametrized as well. As a consequence, message formats might vary for different compositions of board and experiment setup packages. 
% Since the widths of these buses are known at compile-time, the parametrization 

In order to support this dynamic behaviour, the boundaries between different sections of the message must be determined based on the width definitions for the address and data buses of the experiment setup package. The equations displayed in figure \ref{fig:message-parametrization-equations} define how other message format parameters are expressed in terms of the widths of these buses. Every section is defined to span at least one byte. As a result, the minimum message width is defined to be three bytes wide. This decision was made to allow for simplified debugging and processing on the PC, since a byte corresponds to a PC's unit of memory and sections can thus be easily separated. Furthermore, it guarantees the \texttt{Value} section of value-types messages to have a width of at least 16 bits, large enough for reasonably sized integer representations. If the section is wider than the corresponding signal due to rounding, the unused bits are located on the MSB end of the section and are set to be zero. All arguments represent unsigned integers and are thus unaffected when interpreted as bytes. 


\begin{figure}[h]
    \caption{Equations for message format parametrization in terms of $address\ width$ and $data\ width$. Every message section is defined to span at least one byte.}
    \label{fig:message-parametrization-equations}
    \centering
    \begin{empheq}[box=\fbox]{align*}
    % \begin{align*}
        \# command\ opcodes     &= 7 \\
        \# response\ opcodes    &= 12 \\
        \# opcode\ bytes        &= \bigg \lceil \frac{max(\#command\ opcodes, \#response\ opcodes)}{256} \bigg \rceil = 1\\
        \# address\ bytes       &= \bigg \lceil \frac{address\ width}{8} \bigg \rceil \\
        \# data\ bytes          &= \bigg \lceil \frac{data\ width}{8} \bigg \rceil \\
        \# message\ bytes       &= \# opcode\ bytes + \# address\ bytes + \# message\ bytes \\
        \# value\ bytes         &= \# address\ bytes + \# data\ bytes \\
        value\ width            &= 8 \cdot \# value\ bytes
    % \end{align*}
    \end{empheq}
\end{figure}

\subsection{Controller}


\section{Composition Package Specification}



\section{Package Composer}



\section{Experimenter Shell}



\end{document}